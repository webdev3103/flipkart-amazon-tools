var Q=Object.defineProperty;var j=(g,e,t)=>e in g?Q(g,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):g[e]=t;var R=(g,e,t)=>j(g,typeof e!="symbol"?e+"":e,t);import{f as u,z as m,n as I,o as C,p as G,l as P,T as F,t as _,u as K,q as U,m as M,x as b,v as J,aA as V}from"./firebase-vendor-40dJGoDN.js";import{an as W,r as A,ao as S,f as k,b as N,ap as q,d as X,aq as x,c as B,e as Z}from"./index-D4QRAU_W.js";class tt{constructor(){R(this,"isNativePlatform");this.isNativePlatform=W.isNativePlatform()}async blobToBase64(e){return new Promise((t,s)=>{const a=new FileReader;a.onload=()=>{const n=a.result.split(",")[1];t(n)},a.onerror=s,a.readAsDataURL(e)})}async uploadFile(e,t,s){try{const r=u().currentUser;if(!r)throw console.error("Authentication error: No user is currently signed in"),new Error("User must be authenticated to upload files");if(this.isNativePlatform){console.warn("File upload on native platform using web SDK fallback");const n=A(S,t),i={...s,customMetadata:{userId:r.uid,uploadedAt:Date.now().toString(),...s==null?void 0:s.customMetadata}},o=await k(n,e,i);return await N(o.ref)}else{const n=A(S,t),i={...s,customMetadata:{userId:r.uid,uploadedAt:Date.now().toString(),...s==null?void 0:s.customMetadata}},o=await k(n,e,i);return await N(o.ref)}}catch(a){throw console.error("Error uploading file:",a),a}}async getFileUrl(e){try{if(this.isNativePlatform)return(await q.getDownloadUrl({path:e})).downloadUrl;{const t=A(S,e);return await N(t)}}catch(t){throw console.error("Error getting file URL:",t),t}}async deleteFile(e){try{if(this.isNativePlatform)await q.deleteFile({path:e});else{const t=A(S,e);await X(t)}}catch(t){throw console.error("Error deleting file:",t),t}}async listFiles(e){try{if(this.isNativePlatform)throw console.warn("listFiles is not supported on native platforms with Capacitor Firebase Storage"),new Error("File listing is not supported on native platforms");{const t=A(S,e);return(await x(t)).items.map(a=>a.fullPath)}}catch(t){throw console.error("Error listing files:",t),t}}async getFileMetadata(e){try{if(this.isNativePlatform){const t=await q.getMetadata({path:e});return{bucket:t.bucket||"",fullPath:e,generation:t.generation||"",metageneration:t.generation||"",name:t.name||e.split("/").pop()||"",size:t.size||0,timeCreated:t.createdAt||new Date().toISOString(),updated:t.updatedAt||new Date().toISOString(),md5Hash:t.md5Hash,cacheControl:t.cacheControl,contentDisposition:t.contentDisposition,contentEncoding:t.contentEncoding,contentLanguage:t.contentLanguage,contentType:t.contentType||"application/octet-stream",customMetadata:t.customMetadata||{},downloadTokens:[],ref:{},type:"file"}}else{const t=A(S,e);return await B(t)}}catch(t){throw console.error("Error getting file metadata:",t),t}}async updateFileMetadata(e,t){try{if(this.isNativePlatform)throw console.warn("updateFileMetadata is limited on native platforms with Capacitor Firebase Storage"),new Error("Metadata updates are not supported on native platforms");{const s=A(S,e);return await Z(s,{customMetadata:t})}}catch(s){throw console.error("Error updating file metadata:",s),s}}generateFilePath(e,t){const a=u().currentUser;if(!a)throw console.error("Authentication error: No user is currently signed in"),new Error("User must be authenticated to generate file paths");const r=a.uid,n=Date.now(),i=t.replace(/[^a-zA-Z0-9.-]/g,"_");return`${e}/${r}/${n}_${i}`}isAuthenticated(){return!!u().currentUser}}const z=new tt;var v=(g=>(g.USER="user",g.ADMIN="admin",g.SUPERUSER="superuser",g))(v||{});class et{constructor(){R(this,"USERS_COLLECTION","users")}async getCurrentUserRole(){const t=u().currentUser;if(!t)return v.USER;try{const s=m(),a=I(s,this.USERS_COLLECTION,t.uid),r=await C(a);return r.exists()&&r.data().role||v.USER}catch(s){return console.error("Error fetching user role:",s),v.USER}}async hasAdminAccess(){const e=await this.getCurrentUserRole();return[v.ADMIN,v.SUPERUSER].includes(e)}async getUserDetails(e){try{const t=m(),s=I(t,this.USERS_COLLECTION,e),a=await C(s);if(a.exists()){const r=a.data(),i=u().currentUser;return{id:e,email:r.email||"",displayName:r.displayName||"",role:r.role||v.USER,photoURL:r.photoURL||(i==null?void 0:i.photoURL)}}return null}catch(t){return console.error("Error fetching user details:",t),null}}async getUserDetailsMap(e){const s=[...new Set(e)].map(r=>this.getUserDetails(r));return(await Promise.all(s)).reduce((r,n)=>(n&&(r[n.id]=n),r),{})}}const H=new et,Y={expiryDays:30,restrictAccess:!0,isShared:!1,visibility:"private"};class rt{constructor(){R(this,"STORAGE_PATH","pdfs");R(this,"COLLECTION_NAME","pdfs")}generateDateBasedPath(e,t){const s=t||new Date,a=String(s.getDate()).padStart(2,"0"),r=String(s.getMonth()+1).padStart(2,"0"),n=s.getFullYear(),i=`${a}-${r}-${n}`;return`${this.STORAGE_PATH}/${i}`}getTodaysFolderPath(){const t=u().currentUser;return t?this.generateDateBasedPath(t.uid):null}getTodaysDateString(){const e=new Date,t=String(e.getDate()).padStart(2,"0"),s=String(e.getMonth()+1).padStart(2,"0"),a=e.getFullYear();return`${t}-${s}-${a}`}getDateString(e){const t=String(e.getDate()).padStart(2,"0"),s=String(e.getMonth()+1).padStart(2,"0"),a=e.getFullYear();return`${t}-${s}-${a}`}getFolderPathForDate(e){const s=u().currentUser;return s?this.generateDateBasedPath(s.uid,e):null}async listTodaysFiles(){try{if(!u().currentUser)throw new Error("User must be authenticated to access files");return await this.listFilesForDate(new Date)}catch(e){if(e instanceof Error&&e.message.includes("folder does not exist"))return[];throw e}}async listFilesForDate(e){try{if(!u().currentUser)throw new Error("User must be authenticated to access files");const a=this.getDateString(e),r=`${this.STORAGE_PATH}/${a}`,n=[];try{const i=await this.listFolderContents(r);n.push(...i)}catch{return[]}return n}catch(t){if(t instanceof Error&&t.message.includes("folder does not exist"))return[];throw t}}async uploadPdf(e,t,s,a=Y){try{const n=u().currentUser;if(!n)return console.error("Authentication error: No user is currently signed in"),{success:!1,error:"User must be authenticated to upload files",fileId:"",downloadUrl:"",expiresAt:0,isShared:!1,restrictAccess:!0,metadata:{userId:"",uploadedAt:0,expiresAt:0,originalFileName:t,fileSize:0,restrictAccess:!0,isShared:!1,visibility:"private",description:""}};const i=Date.now(),o=n.uid,c=this.generateDateBasedPath(o),d=t.replace(/[^a-zA-Z0-9.-]/g,"_"),h=new Date().toISOString().replace(/[:.]/g,"-").substring(11,19),y=`${c}/${h}_${d}`,f=Math.max(1,Math.min(90,a.expiryDays)),l=new Date;l.setDate(l.getDate()+f);const p=l.getTime(),w={userId:o,fileId:"",expiresAt:p.toString(),visibility:a.visibility||"private",description:s.description||a.description||""},D=A(S,y),E=await k(D,e,{contentType:"application/pdf",customMetadata:w}),L=await N(E.ref),T={userId:o,uploadedAt:i,expiresAt:p,originalFileName:t,fileSize:e.size,restrictAccess:a.restrictAccess,isShared:a.isShared,visibility:a.visibility||"private",storagePath:y,stats:{categoryCount:s.categoryCount,productCount:s.productCount,sortConfig:s.sortConfig},description:s.description||a.description},O=m(),$=await G(P(O,this.COLLECTION_NAME),{...T,storagePath:y,downloadUrl:L,uploadedAt:F.fromMillis(i),expiresAt:F.fromMillis(p)});return await Z(D,{customMetadata:{fileId:$.id}}),{fileId:$.id,downloadUrl:L,expiresAt:p,isShared:a.isShared,restrictAccess:a.restrictAccess,metadata:T,success:!0}}catch(r){return console.error("Error uploading PDF:",r),{success:!1,error:r instanceof Error?r.message:"Unknown error during upload",fileId:"",downloadUrl:"",expiresAt:0,isShared:!1,restrictAccess:!0,metadata:{userId:"",uploadedAt:0,expiresAt:0,originalFileName:t,fileSize:0,restrictAccess:!0,isShared:!1,visibility:"private",description:""}}}}async uploadPdfForDate(e,t,s,a,r=Y){try{const i=u().currentUser;if(!i)return console.error("Authentication error: No user is currently signed in"),{success:!1,error:"User must be authenticated to upload files",fileId:"",downloadUrl:"",expiresAt:0,isShared:!1,restrictAccess:!0,metadata:{userId:"",uploadedAt:0,expiresAt:0,originalFileName:t,fileSize:0,restrictAccess:!0,isShared:!1,visibility:"private",description:""}};console.debug("Starting PDF upload for date:",s.toISOString().split("T")[0],"with auth user:",i.uid);const o=Date.now(),c=i.uid,d=this.generateDateBasedPath(c,s),h=t.replace(/[^a-zA-Z0-9.-]/g,"_"),y=new Date().toISOString().replace(/[:.]/g,"-").substring(11,19),f=`${d}/${y}_${h}`,l=Math.max(1,Math.min(90,r.expiryDays)),p=new Date;p.setDate(p.getDate()+l);const w=p.getTime(),D={userId:c,fileId:"",expiresAt:w.toString(),visibility:r.visibility||"private",description:a.description||r.description||"",selectedDate:s.toISOString().split("T")[0]},E=A(S,f),L=await k(E,e,{contentType:"application/pdf",customMetadata:D}),T=await N(L.ref),O={userId:c,uploadedAt:o,expiresAt:w,originalFileName:t,fileSize:e.size,restrictAccess:r.restrictAccess,isShared:r.isShared,visibility:r.visibility||"private",storagePath:f,stats:{categoryCount:a.categoryCount,productCount:a.productCount,sortConfig:a.sortConfig},description:a.description||r.description,selectedDate:s.toISOString().split("T")[0]},$=m();return{fileId:(await G(P($,this.COLLECTION_NAME),{userId:c,uploadedAt:F.fromMillis(o),expiresAt:F.fromMillis(w),originalFileName:t,fileSize:e.size,restrictAccess:r.restrictAccess,isShared:r.isShared,visibility:r.visibility||"private",downloadUrl:T,storagePath:f,stats:O.stats,description:O.description,selectedDate:s.toISOString().split("T")[0]})).id,downloadUrl:T,expiresAt:w,isShared:r.isShared,restrictAccess:r.restrictAccess,metadata:O,success:!0}}catch(n){return console.error("Error uploading PDF for date:",n),{success:!1,error:n instanceof Error?n.message:"Unknown error during upload",fileId:"",downloadUrl:"",expiresAt:0,isShared:!1,restrictAccess:!0,metadata:{userId:"",uploadedAt:0,expiresAt:0,originalFileName:t,fileSize:0,restrictAccess:!0,isShared:!1,visibility:"private",description:""}}}}async getPdfDetails(e){try{if(!u().currentUser)throw new Error("User must be authenticated to view file details");const a=m(),r=I(a,this.COLLECTION_NAME,e),n=await C(r);if(!n.exists())return null;const i=n.data(),o={userId:i.userId,uploadedAt:i.uploadedAt.toMillis(),expiresAt:i.expiresAt.toMillis(),originalFileName:i.originalFileName,fileSize:i.fileSize,restrictAccess:i.restrictAccess,isShared:i.isShared,visibility:i.visibility,storagePath:i.storagePath,stats:i.stats,description:i.description,selectedDate:i.selectedDate};return{fileId:e,downloadUrl:i.downloadUrl,expiresAt:o.expiresAt,isShared:o.isShared,restrictAccess:o.restrictAccess,metadata:o,success:!0}}catch(t){throw console.error("Error retrieving PDF details:",t),t}}async deletePdf(e){try{if(!u().currentUser)throw new Error("User must be authenticated to delete files");const a=m(),r=I(a,this.COLLECTION_NAME,e),n=await C(r);if(!n.exists())throw new Error("File not found");const i=n.data();await z.deleteFile(i.storagePath),await _(r)}catch(t){throw console.error("Error deleting PDF:",t),t}}async updatePdfExpiry(e,t){try{if(!u().currentUser)throw new Error("User must be authenticated to update files");const r=Math.max(1,Math.min(90,t)),n=new Date;n.setDate(n.getDate()+r);const i=n.getTime(),o=m(),c=I(o,this.COLLECTION_NAME,e),d=await C(c);if(!d.exists())throw new Error("File not found");const h=d.data();await K(c,{expiresAt:F.fromMillis(i)}),await z.updateFileMetadata(h.storagePath,{expiresAt:i.toString()})}catch(s){throw console.error("Error updating PDF expiry:",s),s}}async listAllPdfs(){try{if(!u().currentUser)throw new Error("User must be authenticated to list files");const s=m(),a=U(P(s,this.COLLECTION_NAME)),r=await M(a);if(r.empty)return[];const n=Date.now(),i=[];return r.forEach(o=>{const c=o.data(),d=c.expiresAt.toMillis();d<n||i.push({fileId:o.id,downloadUrl:c.downloadUrl,expiresAt:d,isShared:c.isShared,restrictAccess:c.restrictAccess,metadata:{userId:c.userId,uploadedAt:c.uploadedAt.toMillis(),expiresAt:d,originalFileName:c.originalFileName,fileSize:c.fileSize,restrictAccess:c.restrictAccess,isShared:c.isShared,visibility:c.visibility,storagePath:c.storagePath,stats:c.stats,description:c.description,selectedDate:c.selectedDate},success:!0})}),i.sort((o,c)=>c.metadata.uploadedAt-o.metadata.uploadedAt)}catch(e){throw console.error("Error listing PDFs:",e),e}}async listUserPdfs(){return this.listAllPdfs()}async cleanupExpiredFiles(){try{if(!u().currentUser)throw new Error("User must be authenticated to clean up files");const s=Date.now(),a=m(),r=U(P(a,this.COLLECTION_NAME),b("expiresAt","<=",F.fromMillis(s))),n=await M(r);if(n.empty)return 0;let i=0;for(const o of n.docs){const c=o.data();try{await z.deleteFile(c.storagePath),await _(o.ref),i++}catch(d){console.error(`Failed to delete expired file ${o.id}:`,d)}}return i}catch(e){throw console.error("Error cleaning up expired files:",e),e}}async listAllFolders(){try{if(!u().currentUser)throw new Error("User must be authenticated to list folders");const s=A(S,this.STORAGE_PATH),a=[],n=(await x(s)).prefixes.map(async o=>{const c=o.fullPath,d=o.name;try{const h=await x(o);let y=0,f=new Date(0);const l=h.items.map(async p=>{try{const w=await B(p),D=w.size||0,E=new Date(w.updated);y+=D,E>f&&(f=E)}catch(w){console.warn(`Failed to get metadata for ${p.fullPath}:`,w)}});return await Promise.all(l),{path:c,name:d,fileCount:h.items.length,totalSize:y,lastModified:f.getTime()===0?new Date:f}}catch(h){return console.warn(`Failed to process date folder ${d}:`,h),null}});return(await Promise.all(n)).forEach(o=>{o&&a.push(o)}),a.sort((o,c)=>o.name.localeCompare(c.name))}catch(e){throw console.error("Error listing all folders:",e),e}}async listUserFolders(){return this.listAllFolders()}async listFolderContents(e){try{if(!u().currentUser)throw new Error("User must be authenticated to list folder contents");const a=A(S,e),n=(await x(a)).items.map(async o=>{var c,d;try{const[h,y]=await Promise.all([B(o),N(o)]),f=m();let l=null,p=null;try{const w=U(P(f,this.COLLECTION_NAME),b("storagePath","==",o.fullPath)),D=await M(w);if(!D.empty){const E=D.docs[0];p=E.id,l=E.data()}}catch(w){console.warn(`Failed to get Firestore data for ${o.fullPath}:`,w)}return{path:o.fullPath,name:o.name,size:h.size||0,lastModified:new Date(h.updated),downloadUrl:y,fileId:p,metadata:l?{userId:l.userId,uploadedAt:((c=l.uploadedAt)==null?void 0:c.toMillis())||0,expiresAt:((d=l.expiresAt)==null?void 0:d.toMillis())||0,originalFileName:l.originalFileName,fileSize:l.fileSize,restrictAccess:l.restrictAccess,isShared:l.isShared,visibility:l.visibility,storagePath:l.storagePath,stats:l.stats,description:l.description,selectedDate:l.selectedDate}:void 0}}catch(h){return console.error(`Failed to process file ${o.fullPath}:`,h),null}});return(await Promise.all(n)).filter(Boolean).sort((o,c)=>o.name.localeCompare(c.name))}catch(t){throw console.error("Error listing folder contents:",t),t}}async getFolderSize(e){try{if(!u().currentUser)throw new Error("User must be authenticated to get folder size");const a=A(S,e),r=await x(a);let n=0;const i=r.items.map(async c=>{try{return(await B(c)).size||0}catch(d){return console.warn(`Failed to get size for ${c.fullPath}:`,d),0}});return n=(await Promise.all(i)).reduce((c,d)=>c+d,0),n}catch(t){throw console.error("Error getting folder size:",t),t}}async deleteFolderRecursive(e){try{if(!u().currentUser)throw new Error("User must be authenticated to delete folders");const a=A(S,e),r=await x(a),n=r.items.map(async o=>{try{const c=m(),d=U(P(c,this.COLLECTION_NAME),b("storagePath","==",o.fullPath)),y=(await M(d)).docs.map(f=>_(f.ref));await Promise.all(y),await z.deleteFile(o.fullPath)}catch(c){throw console.error(`Failed to delete file ${o.fullPath}:`,c),c}}),i=r.prefixes.map(async o=>{await this.deleteFolderRecursive(o.fullPath)});await Promise.all([...n,...i])}catch(t){throw console.error("Error deleting folder recursively:",t),t}}async deleteFile(e){try{if(!u().currentUser)throw new Error("User must be authenticated to delete files");const a=m(),r=U(P(a,this.COLLECTION_NAME),b("storagePath","==",e)),i=(await M(r)).docs.map(o=>_(o.ref));await Promise.all(i),await z.deleteFile(e)}catch(t){throw console.error("Error deleting file:",t),t}}async deleteMultipleFiles(e){try{if(!u().currentUser)throw new Error("User must be authenticated to delete files");const a=e.map(r=>this.deleteFile(r));await Promise.all(a)}catch(t){throw console.error("Error deleting multiple files:",t),t}}async validateUserAccess(e){try{if(!u().currentUser)throw new Error("User must be authenticated to access files");return!0}catch(t){throw console.error("Error validating user access:",t),t}}async listAllUserPdfs(e={}){try{if(!await H.hasAdminAccess())throw new Error("Insufficient permissions to view all PDFs");const s=m(),a=P(s,this.COLLECTION_NAME);let r=U(a);if(e.filterByDate){const l=new Date(e.filterByDate);l.setHours(0,0,0,0);const p=new Date(e.filterByDate);p.setHours(23,59,59,999),r=U(r,b("uploadedAt",">=",F.fromDate(l)),b("uploadedAt","<=",F.fromDate(p)))}e.searchTerm&&(r=U(r,b("originalFileName",">=",e.searchTerm),b("originalFileName","<=",e.searchTerm+"ï£¿")));const n=e.sortBy||"uploadedAt",i=e.sortOrder||"desc";r=U(r,J(n,i));const o=e.pageSize||50,c=U(r,V(o)),h=(await M(c)).docs.map(l=>({fileId:l.id,downloadUrl:l.data().downloadUrl,expiresAt:l.data().expiresAt.toMillis(),isShared:l.data().isShared,restrictAccess:l.data().restrictAccess,metadata:{userId:l.data().userId,uploadedAt:l.data().uploadedAt.toMillis(),expiresAt:l.data().expiresAt.toMillis(),originalFileName:l.data().originalFileName,fileSize:l.data().fileSize,restrictAccess:l.data().restrictAccess,isShared:l.data().isShared,visibility:l.data().visibility,storagePath:l.data().storagePath,stats:l.data().stats,description:l.data().description,selectedDate:l.data().selectedDate},success:!0})),f=(await M(r)).size;return{pdfs:h,totalCount:f,page:e.page||1,pageSize:o}}catch(t){throw console.error("Error listing all user PDFs:",t),t}}async getUserDetailsForPdfs(e){try{if(!await H.hasAdminAccess())throw new Error("Insufficient permissions to retrieve user details");const s=m(),a=[];for(const r of e){const n=I(s,this.COLLECTION_NAME,r),i=await C(n);if(i.exists()){const o=i.data().userId;o&&!a.includes(o)&&a.push(o)}}return await H.getUserDetailsMap(a)}catch(t){throw console.error("Error getting user details for PDFs:",t),t}}}const nt=new rt;export{Y as d,nt as p,H as r};
