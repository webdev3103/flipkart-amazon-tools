rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Common functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Allow seeding operations in emulator (for development only)
    function isEmulatorSeeding() {
      return true; // This should only be used in emulator environment
    }
    
    function isAdmin() {
      return isAuthenticated() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isValidUserData(data) {
      return data.keys().hasAll(['email', 'role', 'createdAt', 'lastLoginAt']) &&
        data.role in ['user', 'admin'] &&
        data.email is string &&
        data.createdAt is timestamp &&
        data.lastLoginAt is timestamp;
    }

    function isValidTransactionData(data) {
      return data.keys().hasAll(['transactionId', 'platform', 'orderDate', 'sku', 'quantity', 'sellingPrice', 'expenses', 'product', 'metadata', 'hash']) &&
        data.platform in ['amazon', 'flipkart'] &&
        data.expenses is map &&
        data.product is map &&
        data.metadata is map;
    }

    function isValidInventoryMovement(data) {
      return data.keys().hasAll(['categoryGroupId', 'movementType', 'quantity', 'unit', 'previousInventory', 'newInventory', 'createdAt']) &&
        data.categoryGroupId is string &&
        data.movementType in ['deduction', 'addition', 'adjustment', 'initial'] &&
        data.quantity is number &&
        data.quantity != 0 &&
        data.unit in ['kg', 'g', 'pcs'] &&
        data.previousInventory is number &&
        data.newInventory is number &&
        data.createdAt is timestamp &&
        // Validate optional fields if present
        (!data.keys().hasAny(['transactionReference']) || data.transactionReference is string) &&
        (!data.keys().hasAny(['orderReference']) || data.orderReference is string) &&
        (!data.keys().hasAny(['productSku']) || data.productSku is string) &&
        (!data.keys().hasAny(['platform']) || data.platform in ['amazon', 'flipkart']) &&
        (!data.keys().hasAny(['reason']) || data.reason is string) &&
        (!data.keys().hasAny(['notes']) || data.notes is string) &&
        (!data.keys().hasAny(['adjustedBy']) || data.adjustedBy is string) &&
        // Validate quantity constraints for large adjustments
        (data.movementType != 'adjustment' || math.abs(data.quantity) <= data.previousInventory * 10);
    }

    function isValidInventoryAlert(data) {
      return data.keys().hasAll(['categoryGroupId', 'alertType', 'currentLevel', 'thresholdLevel', 'unit', 'severity', 'isActive', 'createdAt']) &&
        data.categoryGroupId is string &&
        data.alertType in ['low_stock', 'zero_stock', 'negative_stock'] &&
        data.currentLevel is number &&
        data.thresholdLevel is number &&
        data.unit in ['kg', 'g', 'pcs'] &&
        data.severity in ['low', 'medium', 'high', 'critical'] &&
        data.isActive is bool &&
        data.createdAt is timestamp &&
        // Validate optional fields if present
        (!data.keys().hasAny(['acknowledgedBy']) || data.acknowledgedBy is string) &&
        (!data.keys().hasAny(['acknowledgedAt']) || data.acknowledgedAt is timestamp) &&
        (!data.keys().hasAny(['resolvedAt']) || data.resolvedAt is timestamp);
    }

    function isValidOrderBarcode(data) {
      return data.keys().hasAll(['barcodeId', 'dateDocId', 'orderIndex', 'isCompleted', 'metadata']) &&
        data.barcodeId is string &&
        data.barcodeId.size() > 0 &&
        data.barcodeId.matches('^[0-9]{6,10}$') &&
        data.dateDocId is string &&
        data.dateDocId.matches('^[0-9]{4}-[0-9]{2}-[0-9]{2}$') &&
        data.orderIndex is number &&
        data.orderIndex >= 0 &&
        data.isCompleted is bool &&
        data.metadata is map &&
        data.metadata.keys().hasAll(['productName', 'quantity', 'platform', 'generatedAt']) &&
        data.metadata.productName is string &&
        data.metadata.productName.size() > 0 &&
        data.metadata.quantity is number &&
        data.metadata.quantity > 0 &&
        data.metadata.platform in ['amazon', 'flipkart'] &&
        data.metadata.generatedAt is string &&
        // Validate optional fields if present
        (!data.keys().hasAny(['orderId']) || data.orderId is string) &&
        (!data.keys().hasAny(['completedAt']) || data.completedAt is string) &&
        (!data.keys().hasAny(['completedBy']) || data.completedBy is string) &&
        (!data.keys().hasAny(['createdAt']) || data.createdAt is timestamp) &&
        (!data.keys().hasAny(['updatedAt']) || data.updatedAt is timestamp) &&
        (!data.metadata.keys().hasAny(['sku']) || data.metadata.sku is string) &&
        // Validate completion consistency
        (data.isCompleted == false || (data.keys().hasAll(['completedAt', 'completedBy']) && 
          data.completedAt is string && data.completedBy is string));
    }

    function isValidCategoryGroupInventory(data) {
      return data.keys().hasAll(['name', 'description', 'color', 'currentInventory', 'inventoryUnit', 'inventoryType', 'minimumThreshold']) &&
        data.name is string &&
        data.name.size() > 0 &&
        data.description is string &&
        data.color is string &&
        data.color.matches('^#[0-9A-Fa-f]{6}$') &&
        data.currentInventory is number &&
        data.currentInventory >= 0 &&
        data.inventoryUnit in ['kg', 'g', 'pcs'] &&
        data.inventoryType in ['weight', 'qty'] &&
        data.minimumThreshold is number &&
        data.minimumThreshold >= 0 &&
        // Validate timestamp fields if present
        (!data.keys().hasAny(['createdAt']) || data.createdAt is timestamp) &&
        (!data.keys().hasAny(['updatedAt']) || data.updatedAt is timestamp) &&
        (!data.keys().hasAny(['lastInventoryUpdate']) || data.lastInventoryUpdate is timestamp);
    }

    match /active-orders/{orderId} {
      allow read: if isAuthenticated() || isEmulatorSeeding();
      allow create, update: if isAuthenticated() || isEmulatorSeeding();
      allow delete: if isAuthenticated() || isEmulatorSeeding();
    }
    
    match /orders/{orderId} {
      allow read: if isAuthenticated() || isEmulatorSeeding();
      allow create, update: if isAuthenticated() || isEmulatorSeeding();
      allow delete: if isAuthenticated() || isEmulatorSeeding();
    }
    
    match /activeOrders/{orderId} {
      allow read: if isAuthenticated() || isEmulatorSeeding();
      allow create, update: if isAuthenticated() || isEmulatorSeeding();
      allow delete: if isAuthenticated() || isEmulatorSeeding();
    }

    match /categories/{categoryId} {
      allow read: if isAuthenticated() || isEmulatorSeeding();
      allow create, update: if isAuthenticated() || isEmulatorSeeding();
      allow delete: if isAuthenticated() || isEmulatorSeeding();
    }

    match /categoryGroups/{groupId} {
      allow read: if isAuthenticated() || isEmulatorSeeding();
      allow create, update: if (isAuthenticated() && 
        request.auth.token.email_verified == true &&
        isValidCategoryGroupInventory(request.resource.data)) || isEmulatorSeeding();
      allow delete: if isAuthenticated() || isEmulatorSeeding();
    }

    match /inventoryMovements/{movementId} {
      allow read: if isAuthenticated() || isEmulatorSeeding();
      allow create: if (isAuthenticated() && 
        request.auth.token.email_verified == true &&
        isValidInventoryMovement(request.resource.data)) || isEmulatorSeeding();
      allow update, delete: if false || isEmulatorSeeding(); // Immutable records - no updates after creation
    }

    match /inventoryAlerts/{alertId} {
      allow read: if isAuthenticated() || isEmulatorSeeding();
      allow create, update: if (isAuthenticated() && 
        request.auth.token.email_verified == true &&
        isValidInventoryAlert(request.resource.data)) || isEmulatorSeeding();
      allow delete: if isAuthenticated() || isEmulatorSeeding();
    }

    match /users/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow create: if isAuthenticated() && isValidUserData(request.resource.data);
      allow update: if (isOwner(userId) || isAdmin()) && (
        // Allow lastLoginAt updates during login without full validation
        (request.resource.data.keys().hasOnly(['lastLoginAt']) && request.resource.data.lastLoginAt is timestamp) ||
        // Full validation for other updates
        isValidUserData(request.resource.data)
      );
      allow delete: if isAdmin();
    }
    
    match /transactions/{transactionId} {
      allow read: if isAuthenticated();
      allow create, update: if isAuthenticated() && isValidTransactionData(request.resource.data);
      allow delete: if isAuthenticated() && (
        resource.data.metadata.createdBy == request.auth.uid || isAdmin()
      );
    }
    
    match /products/{productId} {
      allow read: if isAuthenticated() || isEmulatorSeeding();
      allow write: if isAuthenticated() || isEmulatorSeeding();
    }


    match /batches/{batchId} {
      allow read: if isAuthenticated() || isEmulatorSeeding();
      allow create, update: if isAuthenticated() || isEmulatorSeeding();
      allow delete: if isAuthenticated() || isEmulatorSeeding();
    }

    match /order-barcodes/{barcodeId} {
      // Read access: authenticated users can read barcode data for lookup and scanning
      allow read: if isAuthenticated() || isEmulatorSeeding();

      // Create access: authenticated verified users can create barcodes during PDF processing
      allow create: if (isAuthenticated() &&
        request.auth.token.email_verified == true &&
        isValidOrderBarcode(request.resource.data) &&
        request.resource.data.barcodeId == barcodeId) || isEmulatorSeeding();

      // Update access: only allow completion status updates by verified users
      allow update: if (isAuthenticated() &&
        request.auth.token.email_verified == true &&
        isValidOrderBarcode(request.resource.data) &&
        // Only allow updates that change completion status or add completion metadata
        (resource.data.isCompleted == false && request.resource.data.isCompleted == true) &&
        // Ensure no other fields are modified except completion-related ones
        resource.data.diff(request.resource.data).affectedKeys().hasOnly(['isCompleted', 'completedAt', 'completedBy', 'updatedAt']) &&
        // Validate completion data
        request.resource.data.completedBy == request.auth.uid &&
        request.resource.data.completedAt is string) || isEmulatorSeeding();

      // Delete access: only admins can delete barcode records for data cleanup
      allow delete: if isAdmin() || isEmulatorSeeding();
    }

    match /flipkartReturns/{returnId} {
      // Read access: authenticated users can view returns data
      allow read: if isAuthenticated() || isEmulatorSeeding();

      // Create access: authenticated users can upload returns from Excel files
      allow create: if isAuthenticated() || isEmulatorSeeding();

      // Update access: authenticated users can update return status and QC information
      allow update: if isAuthenticated() || isEmulatorSeeding();

      // Delete access: authenticated users can delete returns
      allow delete: if isAuthenticated() || isEmulatorSeeding();
    }
  }
}